
http连接处理类
===============
根据状态转移,通过主从状态机封装了http连接类。其中,主状态机在内部调用从状态机,从状态机将处理状态和数据传给主状态机
> * 客户端发出http连接请求
> * 从状态机读取数据,更新自身状态和接收数据,传给主状态机
> * 主状态机根据从状态机状态,更新自身状态,决定响应请求还是继续读取


## 基础知识
### epoll
- epoll 将用户关心的文件描述符上的时间放在内核里的一个事件表中，无需重复传入fd或事件集

**三种函数的差异**  
- select通过**线性表描述文件描述符集合**，文件描述符有上限，一般是1024，但可以修改源码，重新编译内核，不推荐
- poll是**链表描述**，突破了文件描述符上限，最大可以打开文件的数目
- epoll通过**红黑树描述**，最大可以打开文件的数目，可以通过命令ulimit -n number修改，仅对当前终端有效


**LT&ET**
水平模式只要有数据就会一直触发（从低电平到高电平之后就一直保持高电平）； 
边缘触发只会触发一次，所以触发之后需要将所有的数据全部读取完（循环调用直到出现EWOULDBLOCK或EAGAIN表示读取完成）
```c++
listen_fd_event.events |= EPOLLET; // 设置使用ET
```
- LT通知之后可以不立即处理该事件，之后会再次通知该事件。
  - 如果存在大量你不需要读写的fd，而它们每次都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率
- ET通知之后必须立即处理
  - 降低了同一个epoll事件被重复触发的次数，因此效率更高

> 使用ET模式的fd都应该是非阻塞的，否则读或写操作因为没有后续事件而一直处于阻塞状态（饥渴状态）
> > 因为ET需要知道数据是否全部读取，需要函数的返回，如果阻塞，那么函数不会返回，这样ET中的循环就没有办法退出
> 
> 为什么不应该使用多线程读写同一个socket连接？
> >当有两个线程同时写一个socket时，当第一个线程A获得了内核缓冲区的使用权，写了一半发现满了，无奈停止写入。
> 当第二次可写事件发生的时候，程序并不知道线程A有没有完整写完数据，这时候另一个线程B抢在A之前竞争得到了内核缓冲区的使用权，
> 开始往里面写数据。 这样导致了一个严重的后果，线程A的数据仅仅写了一半，就被线程B的数据“乱入”。
> 对于解析应答数据的客户端来说，AB混杂的数据完全没有办法解析，那么这次通信就是完全失败的。
> (**简而言之**：两个线程可能将不一致的数据写入到一个socket中)
> 
> 为什么tcp连接socket不应该加锁？
> >在等待发送完整数据包的过程中，整个线程是处于一个阻塞的状态。从效率上来说，与单线程阻塞send无异;
> 从安全性来说，就像陈硕所说的，如果客户端设定接收窗口极其小，或者接收速度非常慢，你的线程将会阻塞相当一段长的时间。
> 如果多来几个这样的客户端，你的所有线程都会被阻塞，你的程序也就死掉了。

**EPOLLONESHOT**  
ET模式下，socket上的事件可能多次触发，并发情况下，可能会使得两个不同的线程处理同一个socket。  
操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次。这样，其他线程就不会操作这个socket了。
（处理完毕之后，要重置）  
完成socket上的一次请求之后，又收到socket上的新的客户请求，该线程继续为socket服务，因为该socket上设置了EPOLLONESHOT
其他线程无法接触这个socket，但是超时之后，线程会放弃这个socket并重置EPOLLONESHOT状态，让其他线程有机会使用这个socket

### HTTP
#### **状态码**
>1xx：指示信息--表示请求已接收，继续处理。
> 
>2xx：成功--表示请求正常处理完毕。
200 OK：客户端请求被正常处理。
206 Partial content：客户端进行了范围请求。
>
>3xx：重定向--要完成请求必须进行更进一步的操作。
301 Moved Permanently：永久重定向，该资源已被永久移动到新位置，将来任何对该资源的访问都要使用本响应返回的若干个URI之一。
302 Found：临时重定向，请求的资源现在临时从不同的URI中获得。
>
>4xx：客户端错误--请求有语法错误，服务器无法处理请求。
400 Bad Request：请求报文存在语法错误。
403 Forbidden：请求被服务器拒绝。
404 Not Found：请求不存在，服务器上找不到请求的资源。
>
>5xx：服务器端错误--服务器处理请求出错。
500 Internal Server Error：服务器在执行请求时出现错误。

#### 报文处理流程
- 浏览器端发出http连接请求，主线程创建http对象接收请求并将所有数据读入对应buffer，将该对象插入任务队列，工作线程从任务队列中取出一个任务进行处理。
- 工作线程取出任务后，调用process_read函数，通过主、从状态机对请求报文进行解析。
- 解析完之后，跳转do_request函数生成响应报文，通过process_write写入buffer，返回给浏览器端。



