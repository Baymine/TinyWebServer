
同步/异步日志系统
===============
同步/异步日志系统主要涉及了两个模块，一个是日志模块，一个是阻塞队列模块,其中加入阻塞队列模块主要是解决异步写入日志做准备.
> * 自定义阻塞队列
> * 单例模式创建日志
> * 同步日志
> * 异步日志
> * 实现按天、超行分类

# [基础知识](https://mp.weixin.qq.com/s?__biz=MzAxNzU2MzcwMw==&mid=2649274294&idx=1&sn=92cd2fbbca55c6db18df4f523b1dca6a&chksm=83ffbeeeb48837f8a0bf27b359137202ad84ac659d44f4e771bd5dd4f88ad3866cd3a32393fd&cur_album_id=1339230165934882817&scene=189#wechat_redirect)
## 单例模式
实现思路：私有化它的构造函数，以防止外界创建单例类的对象；使用类的私有静态指针变量指向类的唯一实例，
并用一个公有的静态方法获取该实例。

**两种实现方式**：
- 懒汉模式
  - 当实例需要的时候才进行初始化
    - 通过条件判断、加锁、私有化构造函数的方式保证单例
    - 利用一个静态变量保存单例
      - C++11以后，要求编译器保证内部静态变量的线程安全性
      - 注意：静态函数只能访问静态成员
- 饿汉模式
  - 在程序运行时就定义了对象，并对其初始化。
  - 不需要加锁，获取单例的函数只是取出这个单例的指针
  - 存在的问题
    - 非静态对象（函数外的static对象）在不同编译单元中的初始化顺序是未定义的。
    - 如果在初始化完成之前调用 getInstance() 方法会返回一个未定义的实例。
## 条件变量
`pthread_cond_wait`: 函数内部会有一次解锁和加锁操作.
等待阶段会进行解锁，当条件满足之后，会加锁
- 为什么要把调用线程放入条件变量的请求队列后再解锁？
  - 防止在加入之前，环境发生变化，而没有被放在等待队列上，导致A忽略了等待条件被满足的信号。
- 为什么判断线程执行的条件用while而不是if？
  - 防止虚假唤醒

## 消费者-生产者模型
生产者和消费者是互斥关系，两者对缓冲区访问互斥，同时生产者和消费者又是一个相互协作与同步的关系，
只有生产者生产之后，消费者才能消费。

# [日志类的定义和使用](https://mp.weixin.qq.com/s?__biz=MzAxNzU2MzcwMw==&mid=2649274302&idx=1&sn=6f171c606e0ce4b9ad23910b2e05275c&chksm=83ffbee6b48837f056543d99ee6daa6f73d9f90c43329f966c43d56dd2cff583413930f75ea1&cur_album_id=1339230165934882817&scene=189#wechat_redirect)
主要的技术难点在于异步写入的过程，因为这个过程需要先将日志信息写入到阻塞队列中，这样就相当于一个生产者。
同时在加入生产过程中，还存在通知机制，这个时候需要涉及条件变量的选用。
在log创建的时候，使用了单例模式

